use crate::types::{BlockHash, StorageKey, StorageValue};
use jsonrpc_core::Error;
use jsonrpc_core_client::{transports::ws, RpcError};
use jsonrpc_derive::rpc;

#[rpc]
pub trait Rpc {
    #[rpc(name = "chain_getBlockHash")]
    fn block_hash(&self, block_number: Option<u32>) -> Result<BlockHash, Error>;

    #[rpc(name = "state_getStorage")]
    fn get_storage(
        &self,
        key: StorageKey,
        block_hash: Option<BlockHash>,
    ) -> Result<StorageValue, Error>;

    #[rpc(name = "state_getKeysPaged")]
    fn get_keys(
        &self,
        prefix: StorageKey,
        count: usize,
        start_key: Option<StorageKey>,
        at: Option<BlockHash>,
    ) -> Result<Vec<StorageKey>, Error>;
}

type RpcResult<T> = Result<T, RpcError>;

/// A JSONRPC aleph client that uses a websocket transport.
///
/// The WS transport makes it easy to cheaply multiplex requests within a single connection.
pub struct Client {
    /// This inner client type is generated by the `#[rpc]` macro.
    client: gen_client::Client,
}

const CHUNK_SIZE: usize = 1000usize;

impl Client {
    /// Connect to the given websocket endpoint (eg. `"wss://ws.test.azero.dev"`).
    pub async fn new(endpoint: &str) -> RpcResult<Client> {
        Ok(Client {
            client: ws::try_connect(endpoint)?.await?,
        })
    }

    /// Find the hash of the best known block.
    pub async fn best_block(&self) -> RpcResult<BlockHash> {
        Ok(self.client.block_hash(None).await?)
    }

    /// Fetch all keys in the `at` block.
    pub async fn all_keys(&self, at: &BlockHash) -> RpcResult<Vec<StorageKey>> {
        let empty_prefix = StorageKey::new("0x");
        let mut start_key = None;
        let mut keys = vec![];

        loop {
            let new_keys = self
                .client
                .get_keys(
                    empty_prefix.clone(),
                    CHUNK_SIZE,
                    start_key,
                    Some(at.clone()),
                )
                .await?;

            keys.extend_from_slice(&new_keys);

            if new_keys.len() < CHUNK_SIZE {
                break;
            }

            start_key = new_keys.last().map(|x| x.clone());
        }

        Ok(keys)
    }

    /// Fetch the value under `key` in the `at` block.
    pub async fn get_storage(&self, key: StorageKey, at: BlockHash) -> RpcResult<StorageValue> {
        Ok(self.client.get_storage(key, Some(at)).await?)
    }
}
